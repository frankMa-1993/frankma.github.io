# Rust入门（十三）：模式与模式匹配

模式是 Rust 中特殊的语法，它用来匹配类型中的结构，无论类型是简单还是复杂。结合使用模式和 `match` 表达式以及其他结构可以提供更多对程序控制流的支配权

## match分支

一个模式常用的位置是 `match` 表达式的分支，`match` 表达式必须是 **穷尽**（*exhaustive*）的，意为 `match` 表达式所有可能的值都必须被考虑到。有一个特定的模式 `_` 可以匹配所有情况，不过它从不绑定任何变量。

```rust
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```

## if let

`if let` 表达式，以及它是如何主要用于编写等同于只关心一个情况的 `match` 语句简写的。也可以组合并匹配 `if let`、`else if` 和 `else if let` 表达式

```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {}, as the background", color);
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}
```

## 循环

一个与 `if let` 结构类似的是 `while let` 条件循环，它允许只要模式匹配就一直进行 `while` 循环。

```rust
let mut stack = Vec::new();
stack.push(1);
stack.push(2);
stack.push(3);
while let Some(top) = stack.pop() {
    println!("{}", top);
}
```

`for` 循环是 Rust 中最常见的循环结构， `for` 可以获取一个模式。在 `for` 循环中，模式是 `for` 关键字直接跟随的值，如下：这里使用 `enumerate` 方法适配一个迭代器来产生一个值和其在迭代器中的索引，第一个产生的值是元组 `(0, 'a')`。当这个值匹配模式 `(index, value)`，`index` 将会是 0 而 `value` 将会是 `'a'`，并打印出第一行输出。

```rust
let v = vec!['a', 'b', 'c'];
for (index, value) in v.iter().enumerate() {
    println!("{} is at index {}", value, index);
}
```

## let

`let` 语句也可以使用模式进行匹配，正如`let x = 5 ` 这样的例子： `x` 是一个代表 “将匹配到的值绑定到变量 x” 的模式。同时因为名称 `x` 是整个模式，这个模式实际上等于 “将任何值绑定到变量 `x`，不管值是什么”。

`let` 和模式解构一个元组，编译器比较值 `(1, 2, 3)` 与模式 `(x, y, z)` 并发现此值匹配这个模式。在这个例子中，将会把 `1` 绑定到 `x`，`2` 绑定到 `y` 并将 `3` 绑定到 `z`。你可以将这个元组模式看作是将三个独立的变量模式结合在一起，如果模式中元素的数量不匹配元组中元素的数量，则整个类型不匹配，并会得到一个编译时错误：

```rust
let (x, y, z) = (1, 2, 3);
//如下产生编译错误
let (x, y) = (1, 2, 3);
```

## 函数

函数参数也可以是模式，如下：`x` 部分就是一个模式，类似于之前对 `let` 所做的，可以在函数参数中匹配元组

```rust
fn foo(x: i32) {
    // code goes here
}
```

## 可反驳性

模式有两种形式：refutable（可反驳的）和 irrefutable（不可反驳的）。能匹配任何传递的可能值的模式被称为是 **不可反驳的**（*irrefutable*）。一个例子就是 `let x = 5;` 语句中的 `x`，因为 `x` 可以匹配任何值所以不可能会失败。对某些可能的值进行匹配会失败的模式被称为是 **可反驳的**（*refutable*）。一个这样的例子便是 `if let Some(x) = a_value` 表达式中的 `Some(x)`；如果变量 `a_value` 中的值是 `None` 而不是 `Some`，那么 `Some(x)` 模式不能匹配。

- 函数参数、 `let` 语句和 `for` 循环只能接受不可反驳的模式
- `if let` 和 `while let` 表达式被限制为只能接受可反驳的模式，因为根据定义他们意在处理可能的失败：条件表达式的功能就是根据成功或失败执行不同的操作。

为了修复在需要不可反驳模式的地方使用可反驳模式的情况，可以修改使用模式的代码：不同于使用 `let`，可以使用 `if let`。如此，如果模式不匹配，大括号中的代码将被忽略，其余代码保持有效。

```rust
if let Some(x) = some_option_value {
        println!("{}", x);
}
```

## 所有的模式语法

- 匹配字面值

模式可以直接匹配字面值模式

```rust
let x = 1;
match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

- 匹配变量名

`match` 表达式中作为模式的一部分声明的变量会覆盖 `match` 结构之外的同名变量，与所有变量一样，如下的例子：匹配分支中的模式引入了一个新变量 `y`，它会匹配任何 `Some` 中的值。因为我们在 `match` 表达式的新作用域中，这是一个新变量，而不是开头声明为值 10 的那个 `y` ，所以这个分支的表达式将会执行并打印出 `Matched, y = 5`。

```rust
let x = Some(5);
let y = 10;
match x {
    Some(50) => println!("Got 50"),
    Some(y) => println!("Matched, y = {:?}", y),
    _ => println!("Default case, x = {:?}", x),
}
println!("at the end: x = {:?}, y = {:?}", x, y);
```

- 多个模式

在 `match` 表达式中，可以使用 `|` 语法匹配多个模式

```rust
let x = 1;
match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

- 范围匹配

`..=` 语法允许你匹配一个闭区间范围内的值，如下：如果 `x` 是 1、2、3、4 或 5，第一个分支就会匹配，范围只允许用于数字或 `char` 值

```rust
let x = 5;
match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}
```

- 解构结构体

带有多个字段的结构体 ，可以通过带有模式的 `let` 语句将其分解，如下：这段代码创建了变量 `a` 和 `b` 来匹配结构体 `p` 中的 `x` 和 `y` 字段。这个例子展示了模式中的变量名不必与结构体中的字段名一致。

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };
    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

但是通常是变量名匹配字段名，所以对于匹配结构体字段的模式存在简写：只需列出结构体字段的名称，则模式创建的变量会有相同的名称。

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };
    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

也可以使用字面值作为结构体模式的一部分进行解构，而不是为所有的字段创建变量，这允许我们测试一些字段为特定值的同时创建其他字段的变量。如下：第一个分支通过指定字段 `y` 匹配字面值 `0` 来匹配任何 y = 0 的点，第二个分支通过指定字段 `x` 匹配字面值 `0` 来匹配 x = 0 的点

```rust
fn main() {
    let p = Point { x: 0, y: 7 };
    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}
```

- 解构枚举

解构枚举的模式需要对应枚举所定义的储存数据的方式。如下：对于像 `Message::Quit` 这样没有任何数据的枚举成员，不能进一步解构其值。只能匹配其字面值 `Message::Quit`，因此模式中没有任何变量。对于像 `Message::Move` 这样的类结构体枚举成员，可以采用类似于匹配结构体的模式；对于像 `Message::Write` 这样的包含一个元素，以及像 `Message::ChangeColor` 这样包含三个元素的类元组枚举成员，其模式则类似于用于解构元组的模式。模式中变量的数量必须与成员中元素的数量一致。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!(
                "Move in the x direction {} and in the y direction {}",
                x, y
            );
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => println!(
            "Change the color to red {}, green {}, and blue {}",
            r, g, b
        ),
    }
}
```

- 解构嵌套的值

模式匹配可以用复杂的方式来混合、匹配和嵌套解构模式。如下是一个复杂结构体的例子，其中结构体和元组嵌套在元组中，并将所有的原始类型解构出来：

```rust
let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 })
```

- 忽略值

下划线（`_`）是可以匹配但不绑定任何值的通配符模式，可以将其用于任意模式，包括函数参数中，如下：这段代码会完全忽略作为第一个参数传递的值 `3`

```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}
fn main() {
    foo(3, 4);
}
```

也可以在一个模式内部使用`_` 忽略部分值，如下：这里忽略了一个五元元组中的第二和第四个值：

```rust
 let numbers = (2, 4, 8, 16, 32);
 match numbers {
        (first, _, third, _, fifth) => {
            println!("Some numbers: {}, {}, {}", first, third, fifth)
        }
}
```

- 忽略未使用的值

如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为这可能会是个 bug。但是有时创建一个还未使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头。如下：这里得到了警告说未使用变量 `y`，不过没有警告说未使用下划线开头的变量。

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

只使用 `_` 和使用以下划线开头的名称有不同：比如 `_x` 仍会将值绑定到变量，而 `_` 则完全不会绑定。如下：因为 `s` 的值仍然会移动进 `_s`，并阻止我们再次使用 `s`。然而只使用下划线本身，并不会绑定值。

```rust
//报错
let s = Some(String::from("Hello!"));
if let Some(_s) = s {
    println!("found a string");
}
println!("{:?}", s);
//可以运行
let s = Some(String::from("Hello!"));
if let Some(_) = s {
    println!("found a string");
}
println!("{:?}", s);
```

- 忽略剩余值

对于有多个部分的值，可以使用 `..` 语法来只使用部分并忽略其它值，`..` 模式会忽略模式中剩余的任何没有显式匹配的值部分。如下：这样可以只匹配其中的 x ，y和z并不需要额外操作

```rust
struct Point {
        x: i32,
        y: i32,
        z: i32,
}
let origin = Point { x: 0, y: 0, z: 0 };
match origin {
    Point { x, .. } => println!("x is {}", x),
}
```

然而使用 `..` 必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错。如下：Rust 不可能决定在元组中匹配 `second` 值之前应该忽略多少个值，以及在之后忽略多少个值

```rust
//报错的
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) => {
            println!("Some numbers: {}", second)
        },
    }
}
```

## 匹配守卫

**匹配守卫**（*match guard*）是一个指定于 `match` 分支模式之后的额外 `if` 条件，它也必须被满足才能选择此分支。匹配守卫用于表达比单独的模式所能允许的更为复杂的情况。

如下的例子：了一个 `match`，其中第一个分支有模式 `Some(x)` 还有匹配守卫 `if x < 5`，其会打印出 `less than five: 4`。当 `num` 与模式中第一个分支比较时，因为 `Some(4)` 匹配 `Some(x)` 所以可以匹配，接着匹配守卫检查 `x` 值是否小于 `5`，因为 `4` 小于 `5`，所以第一个分支被选择；相反如果 `num` 为 `Some(10)`，因为 10 不小于 5 所以第一个分支的匹配守卫为假。

```rust
let num = Some(4);
    match num {
        Some(x) if x < 5 => println!("less than five: {}", x),
        Some(x) => println!("{}", x),
        None => (),
    }
```

如果在匹配守卫中使用 `|` 来指定多个模式，同时匹配守卫的条件会作用于所有的模式，如下：这个匹配条件表明此分支值匹配 `x` 值为 `4`、`5` 或 `6`且`y` 为 `true` 的情况

```rust
let x = 4;
let y = false;
    match x {
        //(4 | 5 | 6) if y => ...
        4 | 5 | 6 if y => println!("yes"),
        _ => println!("no"),
    }
```

## @绑定

*at* 运算符（`@`）允许我们在创建一个存放值的变量的同时测试其值是否匹配模式。如下：我们希望测试 `Message::Hello` 的 `id` 字段是否位于 `3..=7` 范围内，同时也希望能将其值绑定到 `id_variable` 变量中以便此分支相关联的代码可以使用它，例子会打印出 `Found an id in range: 5`。通过在 `3..=7` 之前指定 `id_variable @`，我们捕获了任何匹配此范围的值并同时测试其值匹配这个范围模式。

```rust
    enum Message {
        Hello { id: i32 },
    }
    let msg = Message::Hello { id: 5 };
    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } => println!("Found an id in range: {}", id_variable)
    }
```

